# Shader compilation utilities for SDL_GPU
# Compiles GLSL shaders to SPIRV, DXIL, and MSL formats

# Find required shader compiler tools
find_program(GLSLANG_VALIDATOR glslangValidator)
find_program(SPIRV_CROSS spirv-cross)
find_program(DXC dxc)

if(NOT GLSLANG_VALIDATOR)
    message(FATAL_ERROR "glslangValidator not found. Please install glslang tools.")
endif()

if(NOT SPIRV_CROSS)
    message(WARNING "spirv-cross not found. MSL and DXIL shader compilation will be skipped.")
endif()

# Helper function to convert binary file to C array
function(bin_to_c_array INPUT_FILE OUTPUT_FILE ARRAY_NAME)
    file(READ ${INPUT_FILE} HEX_CONTENT HEX)
    string(LENGTH "${HEX_CONTENT}" HEX_LENGTH)
    math(EXPR BYTE_COUNT "${HEX_LENGTH} / 2")

    set(C_ARRAY "static const unsigned char ${ARRAY_NAME}[${BYTE_COUNT}] = {\n")

    set(COUNTER 0)
    string(REGEX MATCHALL ".." HEX_BYTES "${HEX_CONTENT}")
    foreach(HEX_BYTE ${HEX_BYTES})
        if(COUNTER GREATER 0)
            string(APPEND C_ARRAY ",")
        endif()

        math(EXPR LINE_POS "${COUNTER} % 12")
        if(LINE_POS EQUAL 0)
            string(APPEND C_ARRAY "\n    ")
        endif()

        string(APPEND C_ARRAY "0x${HEX_BYTE}")
        math(EXPR COUNTER "${COUNTER} + 1")
    endforeach()

    string(APPEND C_ARRAY "\n}\\;\n\n")
    file(WRITE ${OUTPUT_FILE} ${C_ARRAY})
endfunction()

# Main function to compile shaders to all formats and generate header
function(compile_shader_to_header)
    set(options "")
    set(oneValueArgs VERTEX_SHADER FRAGMENT_SHADER OUTPUT_HEADER SHADER_NAME)
    set(multiValueArgs "")
    cmake_parse_arguments(SHADER "${options}" "${oneValueArgs}" "${multiValueArgs}" ${ARGN})

    if(NOT SHADER_VERTEX_SHADER OR NOT SHADER_FRAGMENT_SHADER OR NOT SHADER_OUTPUT_HEADER)
        message(FATAL_ERROR "Missing required arguments to compile_shader_to_header")
    endif()

    get_filename_component(SHADER_DIR "${SHADER_OUTPUT_HEADER}" DIRECTORY)
    file(MAKE_DIRECTORY "${SHADER_DIR}")

    set(TEMP_DIR "${CMAKE_BINARY_DIR}/shader_temp/${SHADER_SHADER_NAME}")
    file(MAKE_DIRECTORY "${TEMP_DIR}")

    # Compile GLSL to SPIRV
    set(SPIRV_VERT "${TEMP_DIR}/shader.vert.spv")
    set(SPIRV_FRAG "${TEMP_DIR}/shader.frag.spv")

    message(STATUS "Compiling ${SHADER_VERTEX_SHADER} to SPIRV...")
    execute_process(
        COMMAND ${GLSLANG_VALIDATOR} -V --auto-map-bindings --auto-map-locations ${SHADER_VERTEX_SHADER} -o ${SPIRV_VERT}
        RESULT_VARIABLE RESULT
        ERROR_VARIABLE ERROR_OUTPUT
    )
    if(NOT RESULT EQUAL 0)
        message(FATAL_ERROR "Failed to compile vertex shader: ${ERROR_OUTPUT}")
    endif()

    message(STATUS "Compiling ${SHADER_FRAGMENT_SHADER} to SPIRV...")
    execute_process(
        COMMAND ${GLSLANG_VALIDATOR} -V --auto-map-bindings --auto-map-locations ${SHADER_FRAGMENT_SHADER} -o ${SPIRV_FRAG}
        RESULT_VARIABLE RESULT
        ERROR_VARIABLE ERROR_OUTPUT
    )
    if(NOT RESULT EQUAL 0)
        message(FATAL_ERROR "Failed to compile fragment shader: ${ERROR_OUTPUT}")
    endif()

    # Convert SPIRV to C arrays
    set(SPIRV_VERT_C "${TEMP_DIR}/spirv_vertex.c")
    set(SPIRV_FRAG_C "${TEMP_DIR}/spirv_fragment.c")
    bin_to_c_array(${SPIRV_VERT} ${SPIRV_VERT_C} "spirv_vertex")
    bin_to_c_array(${SPIRV_FRAG} ${SPIRV_FRAG_C} "spirv_fragment")

    # Start building the header file
    set(HEADER_CONTENT "// Generated shader header for ${SHADER_SHADER_NAME}\n")
    string(APPEND HEADER_CONTENT "// DO NOT EDIT - Generated by CMake\n\n")
    string(APPEND HEADER_CONTENT "#pragma once\n\n")

    # Write header preamble
    file(WRITE ${SHADER_OUTPUT_HEADER} ${HEADER_CONTENT})

    # Append SPIRV arrays directly from files to avoid semicolon issues
    file(READ ${SPIRV_VERT_C} SPIRV_VERT_CONTENT)
    file(APPEND ${SHADER_OUTPUT_HEADER} "${SPIRV_VERT_CONTENT}\n")
    file(READ ${SPIRV_FRAG_C} SPIRV_FRAG_CONTENT)
    file(APPEND ${SHADER_OUTPUT_HEADER} "${SPIRV_FRAG_CONTENT}\n")

    # Cross-compile to DXIL if spirv-cross is available
    if(SPIRV_CROSS)
        message(STATUS "Cross-compiling to HLSL/DXIL...")
        set(HLSL_VERT "${TEMP_DIR}/shader.vert.hlsl")
        set(HLSL_FRAG "${TEMP_DIR}/shader.frag.hlsl")

        execute_process(
            COMMAND ${SPIRV_CROSS} ${SPIRV_VERT} --hlsl --shader-model 60 --output ${HLSL_VERT}
            RESULT_VARIABLE RESULT
        )
        execute_process(
            COMMAND ${SPIRV_CROSS} ${SPIRV_FRAG} --hlsl --shader-model 60 --output ${HLSL_FRAG}
            RESULT_VARIABLE RESULT
        )

        # Compile HLSL to DXIL if dxc is available
        if(DXC)
            set(DXIL_VERT "${TEMP_DIR}/shader.vert.dxil")
            set(DXIL_FRAG "${TEMP_DIR}/shader.frag.dxil")

            execute_process(
                COMMAND ${DXC} -T vs_6_0 -E main ${HLSL_VERT} -Fo ${DXIL_VERT}
                RESULT_VARIABLE RESULT
            )
            execute_process(
                COMMAND ${DXC} -T ps_6_0 -E main ${HLSL_FRAG} -Fo ${DXIL_FRAG}
                RESULT_VARIABLE RESULT
            )

            if(EXISTS ${DXIL_VERT} AND EXISTS ${DXIL_FRAG})
                set(DXIL_VERT_C "${TEMP_DIR}/dxil_vertex.c")
                set(DXIL_FRAG_C "${TEMP_DIR}/dxil_fragment.c")
                bin_to_c_array(${DXIL_VERT} ${DXIL_VERT_C} "dxil_vertex")
                bin_to_c_array(${DXIL_FRAG} ${DXIL_FRAG_C} "dxil_fragment")

                file(READ ${DXIL_VERT_C} DXIL_VERT_CONTENT)
                file(APPEND ${SHADER_OUTPUT_HEADER} "${DXIL_VERT_CONTENT}\n")
                file(READ ${DXIL_FRAG_C} DXIL_FRAG_CONTENT)
                file(APPEND ${SHADER_OUTPUT_HEADER} "${DXIL_FRAG_CONTENT}\n")
            endif()
        endif()

        # Cross-compile to MSL
        message(STATUS "Cross-compiling to MSL...")
        set(MSL_VERT "${TEMP_DIR}/shader.vert.metal")
        set(MSL_FRAG "${TEMP_DIR}/shader.frag.metal")

        execute_process(
            COMMAND ${SPIRV_CROSS} ${SPIRV_VERT} --msl --msl-version 20100 --output ${MSL_VERT}
            RESULT_VARIABLE RESULT
        )
        execute_process(
            COMMAND ${SPIRV_CROSS} ${SPIRV_FRAG} --msl --msl-version 20100 --output ${MSL_FRAG}
            RESULT_VARIABLE RESULT
        )

        # On macOS, compile MSL to metallib
        if(APPLE)
            find_program(METAL_COMPILER xcrun)
            if(METAL_COMPILER)
                set(METALLIB_VERT "${TEMP_DIR}/shader.vert.air")
                set(METALLIB_FRAG "${TEMP_DIR}/shader.frag.air")

                execute_process(
                    COMMAND xcrun -sdk macosx metal -c ${MSL_VERT} -o ${METALLIB_VERT}
                    RESULT_VARIABLE RESULT
                )
                execute_process(
                    COMMAND xcrun -sdk macosx metal -c ${MSL_FRAG} -o ${METALLIB_FRAG}
                    RESULT_VARIABLE RESULT
                )

                if(EXISTS ${METALLIB_VERT} AND EXISTS ${METALLIB_FRAG})
                    set(METALLIB_VERT_C "${TEMP_DIR}/metallib_vertex.c")
                    set(METALLIB_FRAG_C "${TEMP_DIR}/metallib_fragment.c")
                    bin_to_c_array(${METALLIB_VERT} ${METALLIB_VERT_C} "metallib_vertex")
                    bin_to_c_array(${METALLIB_FRAG} ${METALLIB_FRAG_C} "metallib_fragment")

                    file(READ ${METALLIB_VERT_C} METALLIB_VERT_CONTENT)
                    file(APPEND ${SHADER_OUTPUT_HEADER} "${METALLIB_VERT_CONTENT}\n")
                    file(READ ${METALLIB_FRAG_C} METALLIB_FRAG_CONTENT)
                    file(APPEND ${SHADER_OUTPUT_HEADER} "${METALLIB_FRAG_CONTENT}\n")
                endif()
            endif()
        endif()
    endif()

    message(STATUS "Generated shader header: ${SHADER_OUTPUT_HEADER}")
endfunction()
